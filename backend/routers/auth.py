# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-04-24T17:57:06+00:00

from __future__ import annotations

from fastapi import APIRouter, Depends, HTTPException

from datetime import datetime
import uuid

#potential vulnerability?
from backend.database import crud, db_schemas
from backend.database import get_db

from sqlalchemy.orm import Session



from ..models.auth_models import (
    EmailPasswordAuth,
    Error,
    NewUser,
    UserAuthenticatePostResponse,
    UserExistsPostRequest,
    UserExistsPostResponse,
    UserNewPostResponse,
)

auth_router = APIRouter()

@auth_router.post(
    '/user/authenticate',
    response_model=UserAuthenticatePostResponse,
    responses={
        '400': {'model': Error},
        '401': {'model': Error},
        '429': {'model': Error},
        '500': {'model': Error},
    },
    tags=['User'],
)
def authenticate_user(
        body: EmailPasswordAuth,
        db: Session = Depends(get_db)
):
    """
    Authenticate a user
    Note: There are some nuances to how this should be handled.
    1. There is a possibility that the password field is JWT token for OAuth providers (this should be checked for)
    1.1. Authentication should first check if the password is a JWT token
    1.2. If it is a JWT token, then the the validity of the token should be checked
    1.3. If the token is valid, then the user should be authenticated using the token and allocated a session
    1.4. The provider is always Google
    2. The filed can also simply represent a password for a user.
    3. The authentication should either return a UserAuthenticationPostResponse or an Error
    """

    # Get user by email
    user = crud.get_user_by_email(db, body.email)
    if not user:
        return Error(error="Invalid email or password")

    # Verify password
    if not crud.verify_password(db, body.email, body.password.get_secret_value()):
        return Error(error="Invalid email or password")

    # Check if user is verified after adding verification process
    #if not user.verified:
    #    return Error(error="Please verify your email before logging in")

    # Generate session token - in this case, we just use the user's token (can be changed later)
    return UserAuthenticatePostResponse(
        sessionToken=str(user.token),
        user={
            "id": user.token,  # Use token as ID
            "email": user.email,
            "name": user.name,
            "createdAt": user.joined_at,
            "verified": user.verified
        }
    )

@auth_router.post(
    '/user/exists',
    response_model=UserExistsPostResponse,
    responses={
        '400': {'model': Error},
        '429': {'model': Error},
        '500': {'model': Error},
    },
    tags=['User'],
)
def check_user_exists(
        body: UserExistsPostRequest,
        db: Session = Depends(get_db)
):
    user = crud.get_user_by_email(db, body.email)
    return UserExistsPostResponse(exists=user is not None)




@auth_router.post(
    '/user/new',
    response_model=None,
    responses={
        '201': {'model': UserNewPostResponse},
        '400': {'model': Error},
        '409': {'model': Error},
        '429': {'model': Error},
        '500': {'model': Error},
    },
    tags=['User'],
)
def create_user(body: NewUser, db: Session = Depends(get_db)):
    # Check if user already exists
    existing_user = crud.get_user_by_email(db, body.email)
    if existing_user:
        return Error(error="User already exists with this email")

    # Create user object
    user_create = db_schemas.UserCreate(
        token=str(uuid.uuid4()),
        joined_at=datetime.now().isoformat(),
        email=body.email,
        name=body.name,
        password=body.password.get_secret_value(),
        is_google_signup=body.googleId is not None,
        verified=True  # Require email verification
    )

    # Create user in database
    user = crud.create_auth_user(db, user_create)

    #TODO: Send verification email

    return UserNewPostResponse(
        message="User created successfully. Please check your email for verification.",
        userId=user.token
    )